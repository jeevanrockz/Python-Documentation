# ðŸ“˜ Project Title: **Wave Dynamics & Interference Simulator**

This project models how waves propagate through a medium and interact with each other. It uses NumPy for numerical computation and Matplotlib for visualization, giving you a hands-on way to explore physics concepts like propagation, reflection, absorption, and interference.

---

## Step 1: Grid Setup
- **Purpose:** Represent a 2D spatial domain where waves can travel.  
- **Implementation:**  
  - A NumPy array (`u`) stores the current wave amplitude at each grid point.  
  - Another array (`u_prev`) stores the previous state.  
  - Initial disturbances (sources) are placed at specific grid points.  
- **Real-world analogy:** Like setting up a pond surface before dropping stones.

---

## Step 2: Laplacian Function
- **Purpose:** Approximate the second spatial derivative (âˆ‡Â²), which governs how waves spread.  
- **Implementation:**  
  - Uses `np.roll` to shift arrays and compute differences with neighbors.  
  - Efficiently calculates the Laplacian without explicit loops.  
- **Application:** This is the core of solving partial differential equations numerically.

---

## Step 3: Update Function
- **Purpose:** Apply the discrete wave equation to evolve the wave field over time.  
- **Implementation:**  
  - Formula:  
    \[
    u_{t+1} = 2u_t - u_{t-1} + c^2 \cdot \Delta t^2 \cdot \nabla^2 u_t
    \]  
  - Uses vectorized NumPy operations for speed.  
- **Application:** Models how energy moves through the medium.

---

## Step 4: Simulation Loop
- **Purpose:** Iterate over time steps to simulate wave evolution.  
- **Implementation:**  
  - Updates `u_prev`, `u`, and `u_next` arrays each frame.  
  - Applies boundary conditions (absorbing edges so waves donâ€™t bounce infinitely).  
- **Application:** Mimics real-world scenarios like sound waves dissipating in a room.

---

## Step 5: Visualization
- **Purpose:** Show the wave propagation dynamically.  
- **Implementation:**  
  - Uses `matplotlib.animation.FuncAnimation` to animate frames.  
  - Color map (`viridis`) represents amplitude (bright = peaks, dark = troughs).  
- **Application:** Helps visualize abstract numerical results in a physical way.

---

## Extensions
- **wave_sources.py:** Multiple sources placed far apart â†’ shows independent ripples.  
- **wave_interference.py:** Sources close together â†’ shows constructive and destructive interference patterns.  
- **wave_3d.py:** Extends simulation to 3D grids â†’ models volumetric wave propagation.  
- **utils.py:** Shared helper functions (`laplacian`, `update_wave`) for modularity.

---

## ðŸ§  Real-World Applications
- **Physics:** Understanding sound, water, or seismic waves.  
- **Engineering:** Designing acoustic systems, antennas, or earthquake simulations.  
- **Computer Graphics:** Creating realistic ripple effects in games or animations.  
- **Medical Imaging:** Modeling ultrasound wave behavior.  

---

## ðŸŽ¯ What You Need to Do
1. Run each script (`wave_simulator.py`, `wave_sources.py`, `wave_interference.py`, `wave_3d.py`) to see different behaviors.  
2. Experiment with parameters:
   - Grid size (`nx, ny`)  
   - Wave speed (`c`)  
   - Source positions and amplitudes  
   - Boundary conditions (absorbing vs reflective)  
3. Observe how changes affect propagation and interference.  
4. Extend the project by adding new scenarios (e.g., random sources, variable wave speeds).  

---

## ðŸš€ Learning Outcomes
By completing this project, youâ€™ll learn:
- How to implement numerical solutions to PDEs with NumPy.  
- How waves propagate and interact in 2D and 3D.  
- How to modularize code into reusable components.  
- How to visualize dynamic simulations effectively.  
